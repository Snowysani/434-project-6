# Compiler Project
This project was made with lots of love and effort. We went to Fuego at midnight after grinding one evening, it was a great time.
This was by far one of the most interesting and educational classes I have taken in my college career. I feel like I have learned more about compilers than many other concepts, and this project was a good learning experience.

# Running Instructions
We utilized our native IDEs to run and test this code's output. It generates BlockDiagram.txt, which can be fed to a graph visualization tool with the Dot language.
This code is run like the previous projects, with command line input of "test.txt" and "test.in". We included some tests in the tests folder.

# Assignment 6 PDF Contents:
So far the compiler does not have any optimizations. This is an advanced assignment to implement some
optimizations discussed.
- Task 1: Your front end must generate an SSA-based intermediate representation (IR) appropriate for
subsequent optimizations. Your intermediate representation will be a dynamic data structure in memory
that models both individual instructions and super-imposed basic blocks. You could perform copy
propagation and common subexpression elimination immediately after this.
- Task 2: After you are confident that your conversion to SSA works correctly, extend your compiler by
adding array operations. That includes performing common subexpression elimination on redundant array
loads that can be eliminated safely, since loads going to memory are among the most expensive operations
on almost any platform.
- Task 3: When you are confident that arrays have been implemented correctly, add user-defined functions
to your language. In the compiler’s IR, each function is modeled as a separate control flow graph. You
will need to introduce an additional type of node in your IR that represents calls, linking the call location
to the function being called and any actual parameters passed in the call to the formal parameters specified
in the called function.
- Task 4: Implement a global register allocator for your compiler. For this purpose, track the live ranges of
all the individual values generated by the program being compiled, and build an interference graph. Color
the resulting graph, assuming that the target machine has 5 general-purpose data registers. If more
registers are required, map the values that cannot be accommodated onto virtual registers in memory.

## Note 1: 
The language does not prohibit the use of uninitialized variables. When you detect such a case, your compiler should emit a warning, but should continue compiling while assigning an initial value of zero.
## Note 2: 
It is almost impossible to debug the kind of complex dynamic data structures that are used in
optimizing compilers without a (graph) visualization tool. While you are free to explore what works for
you, I would suggest using the simplest graph description language around, which is called “Dot” and
which you can quickly learn in 15 minutes. The easiest way to translate a Dot graph description into a
graph image is pasting the Dot program into the http://www.webgraphviz.com website. There are many
open-source graph viewers available as well.
